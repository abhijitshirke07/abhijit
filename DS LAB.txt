========================================================
matrix
0   1  2
-1  0  3
-2 -3  0
===================================================
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    int positive = 1;
    int n;
    cout<<"Enter the dimension of array: "<<endl;
    cin>>n;
    int negative = -1;
    int arr[n][n];
    for(int i = 0; i < n; i++){
      for(int j = 0; j < n; j++){
        if(i == j){
          arr[i][j] = 0;
        }
        else if(i>j){
          arr[i][j] = negative;
          negative--;
        }
        else{
          arr[i][j] = positive;
          positive++;
        }

      }
    }
    cout<<"\n";
    for(int i = 0; i < n; i++){
      for(int j = 0; j < n; j++){
        cout<<setw(5)<<arr[i][j]<<" ";
      }
      cout<<""<<endl;
    }
    return 0;
}

=============================================
circular matrix /spiral matrix
======================================
#include <iostream>
using namespace std;

void fillCircularMatrix(int n, int arr[][10]) {
    int num = 1;
    int startRow = 0, startCol = 0, endRow = n - 1, endCol = n - 1;

    while (startRow <= endRow && startCol <= endCol) {
        // Fill the top row
        for (int i = startCol; i <= endCol; ++i)
            arr[startRow][i] = num++;

        // Fill the right column
        for (int i = startRow + 1; i <= endRow; ++i)
            arr[i][endCol] = num++;

        // Fill the bottom row
        if (startRow < endRow) {
            for (int i = endCol - 1; i >= startCol; --i)
                arr[endRow][i] = num++;
        }

        // Fill the left column
        if (startCol < endCol) {
            for (int i = endRow - 1; i > startRow; --i)
                arr[i][startCol] = num++;
        }

        // Move to the inner matrix
        startRow++;
        startCol++;
        endRow--;
        endCol--;
    }
}

int main() {
    int n;

    cout << "Enter the dimension of the matrix: ";
    cin >> n;

    if (n <= 0 || n > 10) {
        cout << "Invalid dimension. Please enter a positive integer less than or equal to 10." << endl;
        return 1;
    }

    int arr[10][10];

    fillCircularMatrix(n, arr);

    cout << "Circular Matrix:" << endl;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cout << arr[i][j] << "\t";
        }
        cout << endl;
    }

    return 0;
}

===================================================================================================================
Implementation on stack
=====================================================================================================================
#include <iostream>
using namespace std;

int stack[5], n=5, top=-1;

void push(int value) {
   if(top>=n-1)
   cout<<"Stack Overflow"<<endl;
   else {
      top++;
      stack[top]=value;
   }
}
void pop() {
   if(top<=-1)
   cout<<"Stack Underflow"<<endl;
   else {
      cout<<"The popped element is "<< stack[top] <<endl;
      top--;
   }
}
void display() {
   if(top>=0) {
      cout<<"Stack elements are:";
      for(int i=top; i>=0; i--)
      cout<<stack[i]<<" ";
      cout<<endl;
   } else
   cout<<"Stack is empty";
}
int main() {
   int ch, val;
   cout<<"1) Push in the stack"<<endl;
   cout<<"2) Pop from the stack"<<endl;
   cout<<"3) Display the stack"<<endl;
   cout<<"4) Exit"<<endl;
   do {
      cout<<"Enter choice: "<<endl;
      cin>>ch;
      switch(ch) {
         case 1: {
            cout<<"Enter value to be pushed in stack: "<<endl;
            cin>>val;
            push(val);
            break;
         }
         case 2: {
            pop();
            break;
         }
         case 3: {
            display();
            break;
         }
         case 4: {
            cout<<"Exit"<<endl;
            break;
         }
         default: {
            cout<<"Invalid Choice"<<endl;
         }
      }
   }while(ch!=4);
   return 0;
}

================================================================================================================
infix to postfix $ Prefix
================================================================================================================
#include <iostream>
#include <stack>
#include <cctype>

using namespace std;

int astack[100], n = 100, top = -1;

void push(int value) {
    if (top >= n - 1)
        cout << "Stack Overflow" << endl;
    else {
        top++;
        astack[top] = value;
        cout << "Inserted element is: " << value << "\n";
    }
}

int pop() {
    if (top <= -1)
        cout << "Stack Underflow" << endl;
    else {
        int popped = astack[top];
        cout << "The popped element is " << astack[top] << endl;
        top--;
        return popped;
    }
}

int topnum() {
    if (top >= 0) {
        cout << "Top element is: " << astack[top] << "\n\n";
        return astack[top];
    } else {
        cout << "Stack is empty";
        return -1; // Return a default value indicating an empty stack
    }
}

bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/');
}

int getPrecedence(char op) {
    if (op == '+' || op == '-')
        return 1;
    if (op == '*' || op == '/')
        return 2;
    return 0; // Default case for parentheses
}

string infixToPostfix(const string& infix) {
    stack<char> operators;
    string postfix = "";

    for (char c : infix) {
        if (isalnum(c)) {
            postfix += c;
        } else if (c == '(') {
            operators.push(c);
        } else if (c == ')') {
            while (!operators.empty() && operators.top() != '(') {
                postfix += operators.top();
                operators.pop();
            }
            operators.pop();
        } else if (isOperator(c)) {
            while (!operators.empty() && getPrecedence(operators.top()) >= getPrecedence(c)) {
                postfix += operators.top();
                operators.pop();
            }
            operators.push(c);
        }
    }

    while (!operators.empty()) {
        postfix += operators.top();
        operators.pop();
    }

    return postfix;
}

string infixToPrefix(const string& infix) {
    stack<char> operators;
    string prefix = "";

    for (int i = infix.length() - 1; i >= 0; i--) {
        char c = infix[i];

        if (isalnum(c)) {
            prefix = c + prefix;
        } else if (c == ')') {
            operators.push(c);
        } else if (c == '(') {
            while (!operators.empty() && operators.top() != ')') {
                prefix = operators.top() + prefix;
                operators.pop();
            }
            operators.pop();
        } else if (isOperator(c)) {
            while (!operators.empty() && getPrecedence(operators.top()) > getPrecedence(c)) {
                prefix = operators.top() + prefix;
                operators.pop();
            }
            operators.push(c);
        }
    }

    while (!operators.empty()) {
        prefix = operators.top() + prefix;
        operators.pop();
    }

    return prefix;
}

int main() {
    string infixExpression;
    cout << "Enter an infix expression: ";
    cin >> infixExpression;

    string postfixExpression = infixToPostfix(infixExpression);
    string prefixExpression = infixToPrefix(infixExpression);

    cout << "Postfix expression: " << postfixExpression << endl;
    cout << "Prefix expression: " << prefixExpression << endl;

    return 0;
}


==============================================================================================================
Evaluation of postfix
=============================================================================================================

#include<bits/stdc++.h>
using namespace std;
int astack[100], n=100, top=-1;

void push(int value) {
   if(top>=n-1)
   cout<<"Stack Overflow"<<endl;
   else {
      top++;
      astack[top]=value;
      cout<<"Inserted element is: "<<value<<"\n";
   }
}

int pop() {

   if(top<=-1)
   cout<<"Stack Underflow"<<endl;
   else {
      int pop=astack[top];
      cout<<"The popped element is "<< astack[top] <<endl;
      top--;
      return pop;
   }
}

int topnum(){
    if(top>=0){
    cout<<"top element is: "<<astack[top]<<"\n\n";
        return astack[top];
    }
    else{
    cout<<"Stack is empty";
    }
}
int postfixEvaluate(string equation)
{

    for(int i=0; i<equation.length(); i++)
    {
        char value= equation[i];
        if(value>='0' && value <='9')
        {
        int v=int(value-'0');
        push(v);
        }
        else{
            int a=pop();
            int b=pop();
            int ans;
        switch(value){
            case '+':
                ans=a+b;
                cout<<a<<" + "<<b<<" = "<<ans<<endl;
                push(ans);
                break;

            case '-':
                ans=a-b;
                cout<<a<<" - "<<b<<" = "<<ans<<endl;
                push(ans);
                break;
            case '*':
                ans=a*b;
                cout<<a<<" * "<<b<<" = "<<ans<<endl;
                push(ans);
                break;
            case '/':
                ans=a/b;
                cout<<a<<" / "<<b<<" = "<<ans<<endl;
                push(ans);
                break;
        }
        }
        topnum();
        }


}


main(){
   string input;
   cout<<"Enter the postfix: ";
   cin>>input;
   cout <<postfixEvaluate(input);
}

================================================================================================================
Linked List
===============================================================================================================
#include <stdlib.h>
#include <iostream>

using namespace std;


struct Node {
  int data;
  struct Node* next;
};
struct Node* head = NULL;
struct Node* last = head;

void insertnode() {

    int val;
    cout<<"Enter the element  to insert in list: "<<endl;
    cin>>val;
    struct Node* new_node = new Node;
    new_node->data=val;
    new_node->next=NULL;

    if(head==NULL){
        head=new_node;
        last=new_node;
    }else
    if(last->next==NULL){
        last->next=new_node;
        last=new_node;
    }
  }

void deletenode() {
    if (head == NULL) {
        cout << "The list is empty." << endl;
        return;
    }

    int val;
    cout << "Enter the element to delete: ";
    cin >> val;

    struct Node* current = head;
    struct Node* previous = NULL;


    if (current != NULL && current->data == val) {
        head = current->next;
        delete current;
        cout << "Element " << val << " deleted from the list." << endl;
        return;
    }

    while (current != NULL && current->data != val) {
        previous = current;
        current = current->next;
    }

    if (current == NULL) {
        cout << "Element " << val << " not found in the list." << endl;
        return;
    }

    previous->next = current->next;
    delete current;
    cout << "Element " << val << " deleted from the list." << endl;

}

void displaylist() {
    struct Node* current = head;

    cout << "Elements in the list: ";
    while (current != NULL) {
        cout << current->data << " ";
        current = current->next;
    }
    cout << endl;

}


int main() {
    int ch;
    cout<<"1) Insert element to list"<<endl;
    cout<<"2) Delete element from list"<<endl;
    cout<<"3) Display all the elements of list"<<endl;
    cout<<"4) Exit"<<endl;
    do {
     cout<<"Enter your choice : "<<endl;
     cin>>ch;
     switch (ch) {
         case 1: insertnode();
         break;
         case 2: deletenode();
         break;
         case 3: displaylist();
         break;
         case 4: cout<<"Exit"<<endl;
         break;
         default: cout<<"Invalid choice"<<endl;
      }
   } while(ch!=4);
   return 0;
}

==================================================================
line Editor
====================================================================
#include <iostream>
#include <string>

using namespace std;

struct Node {
    string data;
    Node* next;

    Node(const string& text) : data(text), next(nullptr) {}
};

Node* head = nullptr;  // Start with an empty linked list

void insert_in_line() {
    string val;
    cout<<"Enter the element  to insert in list: "<<endl;
    cin.ignore();
    getline(cin,val);

    Node* new_node = new Node(val);
    if (head==NULL) {
        head = new_node;
    } else {
        Node* current = head;
        while (current->next) {
            current = current->next;
        }
        current->next = new_node;
    }
}

void delete_line() {
    int val;
    cout<<"Enter the line no. to delete: "<<endl;
    cin>>val;

    if (val == 1 && head) {
        Node* temp = head;
        head = head->next;
        delete temp;
    } else
    if (val > 1 && head) {
        Node* current = head;
        int count = 1;
        while (current && count < val - 1) {
            current = current->next;
            count++;
        }
        if (current && current->next) {
            Node* temp = current->next;
            current->next = temp->next;
            delete temp;
        }
    }
}

void display_line() {
    Node* current = head;
    int line_no = 1;
    while (current) {
        cout << "Line " << line_no << ": " << current->data << endl;
        current = current->next;
        line_no++;
    }
}

int main() {
    int ch;
    cout<<"1) Insert element into line"<<endl;
    cout<<"2) Delete line number"<<endl;
    cout<<"3) Display all line"<<endl;
    cout<<"4) Exit"<<endl;
    do {
     cout<<"Enter your choice : "<<endl;
     cin>>ch;
     switch (ch) {
         case 1: insert_in_line();
         break;
         case 2: delete_line();
         break;
         case 3: display_line();
         break;
         case 4: cout<<"Exit"<<endl;
         break;
         default: cout<<"Invalid choice"<<endl;
      }
   } while(ch!=4);
   return 0;
}


=================================================================================================
fifo queue
=================================================================================================
#include <iostream>
using namespace std;
struct node {
   int data;
   struct node *next;
};
struct node* front = NULL;
struct node* rear = NULL;
struct node* temp;

void Insert() {
   int val;
   cout<<"Enter the element to insert in queue : "<<endl;
   cin>>val;
   if (rear == NULL) {
      rear = (struct node *)malloc(sizeof(struct node));
      rear->next = NULL;
      rear->data = val;
      front = rear;
   } else {
      temp=(struct node *)malloc(sizeof(struct node));
      rear->next = temp;
      temp->data = val;
      temp->next = NULL;
      rear = temp;
   }
}
void Delete() {
   temp = front;
   if (front == NULL) {
      cout<<"Underflow"<<endl;
      return;
   }
   else
   if (temp->next != NULL) {
      temp = temp->next;
      cout<<"Element deleted from queue is : "<<front->data<<endl;
      free(front);
      front = temp;
   } else {
      cout<<"Element deleted from queue is : "<<front->data<<endl;
      free(front);
      front = NULL;
      rear = NULL;
   }
}
void Display() {
   temp = front;
   if ((front == NULL) && (rear == NULL)) {
      cout<<"Queue is empty"<<endl;
      return;
   }
   cout<<"Queue elements are: ";
   while (temp != NULL) {
      cout<<temp->data<<" ";
      temp = temp->next;
   }
   cout<<endl;
}
int main() {
   int ch;
   cout<<"1) Insert element to queue"<<endl;
   cout<<"2) Delete element from queue"<<endl;
   cout<<"3) Display all the elements of queue"<<endl;
   cout<<"4) Exit"<<endl;
   do {
      cout<<"Enter your choice : "<<endl;
      cin>>ch;
      switch (ch) {
         case 1: Insert();
         break;
         case 2: Delete();
         break;
         case 3: Display();
         break;
         case 4: exit(0);
         break;
         default: cout<<"Invalid choice"<<endl;
      }
   } while(ch!=4);
   return 0;
}


============================================================================
bank queue
============================================================================
#include <iostream>
#include<string>
using namespace std;
struct node {
   string data;
   struct node *next;
};
struct node* front = NULL;
struct node* rear = NULL;
struct node* temp;

void Insert() {
   string val;
   cout<<"Enter your problem: \n";
   cin.ignore();
   getline(cin,val);
   if (rear == NULL) {
      rear = new struct node;
      rear->next = NULL;
      rear->data = val;
      front = rear;
   } else {
      temp= new struct node;
      rear->next = temp;
      temp->data = val;
      temp->next = NULL;
      rear = temp;
   }
}
void Delete() {
   temp = front;
   if (front == NULL) {
      cout<<"Underflow"<<endl;
      return;
   }
   else
   if (temp->next != NULL) {
      temp = temp->next;
      cout<<"Problem deleted from queue is : "<<front->data<<endl;
      free(front);
      front = temp;
   } else {
      cout<<"Problem deleted from queue is : "<<front->data<<endl;
      free(front);
      front = NULL;
      rear = NULL;
   }
}
void Display() {
    int i=1;
    temp = front;
    if ((front == NULL) && (rear == NULL)) {
        cout<<"Queue is empty"<<endl;
        return;
   }
   cout<<"problem in Queue are: \n";
   while (temp != NULL) {
        cout<<"Problem "<<i<<" : ";
        cout<<temp->data<<" \n";
        temp = temp->next;
        i++;
   }
   cout<<endl;
}
int main() {
   int ch;
   cout<<"Bank Manager Queue menu"<<endl;
   cout<<"1) Insert a problem in a queue"<<endl;
   cout<<"2) Delete problem from a queue"<<endl;
   cout<<"3) Display all the problem in queue"<<endl;
   cout<<"4) Exit"<<endl;
   do {
      cout<<"Enter your choice : "<<endl;
      cin>>ch;
      switch (ch) {
         case 1: Insert();
         break;
         case 2: Delete();
         break;
         case 3: Display();
         break;
         case 4: cout<<"Exit"<<endl;
         break;
         default: cout<<"Invalid choice"<<endl;
      }
   } while(ch!=4);
   return 0;
}


=======================================================================
Circular Queue
=======================================================================
#include <bits/stdc++.h>
using namespace std;

struct Node {
	int data;
	struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};


void enqueue(Queue* q)
{
    int val;
    cout<<"Enter the element to insert: ";
    cin>>val;

    struct Node* temp = new Node;
    temp->data = val;
    if (q->front == NULL)
        q->front = temp;
    else
        q->rear->next = temp;

    q->rear = temp;
    q->rear->next = q->front;
}

int dequeue(Queue* q)
{
	if (q->front == NULL) {
		cout << "Queue is empty";	}

	int value;
	if (q->front == q->rear) {
		value = q->front->data;
		free(q->front);
		q->front = NULL;
		q->rear = NULL;
	}
	else
	{
		struct Node* temp = q->front;
		value = temp->data;
		q->front = q->front->next;
		q->rear->next = q->front;
		free(temp);
	}
	cout<<"Deleted item: "<<value<<endl;
	return value;
}


void displayqueue(Queue* q)
{
	struct Node* temp = q->front;
	if(q->front== NULL){
        cout<<"Queue is empty"<<endl;
        }
    else{
	cout <<"\n"<< "Elements in Circular Queue are: ";
	while (temp->next != q->front) {
		cout << temp->data << " ";
		temp = temp->next;
	}
	cout << temp->data;
	cout<<"\n";
	}
}

int main()
{
    Queue* q = new Queue;
    q->front = q->rear = NULL;

    int ch;
    char v;
	cout<<"1. Insert in Queue"<<endl;
	cout<<"2. Delete "<<endl;
	cout<<"3. Display"<<endl;
	cout<<"4. Exit"<<endl;
	do{
        cout<<"Enter choice: ";
        cin>>ch;
        switch(ch){
            case 1: enqueue(q);
            break;
            case 2: dequeue(q);
            break;
            case 3: displayqueue(q);
            break;
            case 4:cout<<"Exit"<<endl;
            }
	}while(ch!=4);
}


======================================================================================
Round Robin queue
=======================================================================================
    #include <iostream>
    using namespace std;


    struct Process {
        string p;
        int arrival_time;
        int burst_time;
        int waiting_time;
        Process* next;
    };

    Process* front = nullptr;
    Process* rear = nullptr;


    void enqueue(string p, int arrival_time, int burst_time)
    {
        Process* process = new Process;
        process->p = p;
        process->arrival_time = arrival_time;
        process->burst_time = burst_time;
        process->waiting_time = burst_time;
        process->next = nullptr;

        if (front == nullptr) {
            front = process;
            rear = process;
            process->next = process;
        } else {
            rear->next = process;
            process->next = front;
            rear = process;
        }
    }


    void dequeue() {
        if (front == nullptr) {
            cout << "Queue is empty." << endl;
            return;
        }

        if (front == rear) {
            delete front;
            front = nullptr;
            rear = nullptr;
        } else {
            Process* temp = front;
            front = front->next;
            rear->next = front;
            delete temp;
        }
    }


    void roundRobin(int timeQuantum) {
        if (front == nullptr) {
            cout << "Queue is empty." << endl;
            return;
        }

        Process* currentProcess = front;
        while (front != nullptr) {
            if (currentProcess->waiting_time > timeQuantum) {
                cout << "Executing process " << currentProcess->p << " for time quantum " << timeQuantum << endl;
                currentProcess->waiting_time -= timeQuantum;
                currentProcess = currentProcess->next;
            } else {
                cout << "Executing process " << currentProcess->p << " for time " << currentProcess->waiting_time << endl;
                currentProcess->waiting_time = 0;
                Process* completedProcess = currentProcess;
                currentProcess = currentProcess->next;
                dequeue();
                delete completedProcess;
            }
        }
    }

    int main() {
        int n,i;
        int time_Quantum;
        cout << "Enter the number of process: ";
        cin >> n;
        cout << "Enter the time quantum for Round Robin: ";
        cin >> time_Quantum;

       for (i=1; i <= n; i++) {
        int arrival_time;
        int burst_time;
        string a="p";
        string p = a + to_string(i);
        cout << "Enter details for Process " << p << ":" << endl;
        cout << "Arrival Time: ";
        cin >> arrival_time;
        cout << "Burst Time: ";
        cin >> burst_time;




            enqueue(p, arrival_time, burst_time);
        }

        roundRobin(time_Quantum);

        return 0;
    }

====================================
Book BST
===============================
#include <iostream>
#include <iomanip>
#include<string>

using namespace std;

struct book_node
{
    int b_id;
    string bname;
    string bauthor;
    int bprice;
    int bpages;
    struct book_node *left;
    struct book_node *right;
};

struct book_node *root = NULL;
void insert(int b_id,string bname,string bauthor,int bprice,int bpages)
{
    struct book_node *data=new book_node();

    data->b_id=b_id;
    data->bname=bname;
    data->bauthor=bauthor;
    data->bprice=bprice;
    data->bpages=bpages;
    data->left=data->right=NULL;
    if(root == NULL)
    {
        root = data;
    }
    else{
        struct book_node *current=new book_node();
        current=root;
        while(current != NULL){
            if(current->b_id > data->b_id){
                if (current->left == NULL) {
                    current->left = data;
                    return;
                    }
                    current = current->left;
                }

                else if(current->b_id < data->b_id){
                    if (current->right == NULL) {
                        current->right = data;
                        return;
                    }current=current->right;
                }
    }
}
}
void Traversal(book_node *node,int depth)
{
     if (node == NULL)
        return;

    const int spacing = 5;
    Traversal(node->right, depth + 1);

    cout << setw(spacing * depth) << "";

    cout<< "ID: " << node->b_id << " || Name: " << node->bname << " || Author: " << node->bauthor << " || Price: " << node->bprice << " || Pages: " << node->bpages << "\n"<<endl;

    Traversal(node->left, depth + 1);
}
void display()
{
    if (root == NULL)
    {
        cout << "Tree is empty" << endl;
    }
    else
    {
        Traversal(root,0);
    }
}

int main(){

    int ch;
    char v;

	do{
        cout<<"\n1. Insert in Queue"<<endl;
        cout<<"2. Display"<<endl;
        cout<<"3. Exit\n"<<endl;
        cout<<"Enter choice: ";
        cin>>ch;
        switch(ch){
            case 1:{
                int n;
                cout<<"Enter number of book to enter :- ";
                cin>> n;
                    for(int i=1;i<=n;i++){
                        int book_id,price,page;
                        string bname,author;
                        cout<<"Enter book id: ";
                        cin>>book_id;
                        cout<<"Enter book name: ";
                        cin>>bname;
                        cout<<"Enter book author: ";
                        cin>>author;
                        cout<<"Enter book price: ";
                        cin>>price;
                        cout<<"Enter book page: ";
                        cin>>page;
                        insert(book_id,bname,author,price,page);
                        cout<<"\n";
                    }
            break;
            }
            case 2: display();
            break;
            case 3:cout<<"Exit"<<endl;
            }
	}while(ch!=3);
}


=====================================================================================
TREE
====================================================================================
#include <iostream>
#include <iomanip>
#include<string>

using namespace std;

struct node
{
    int data;
    struct node *left;
    struct node *right;
};

struct node *root = NULL;

void insert(int data)
{
    struct node *temp =new node();

    temp->data=data;
    temp->left = temp->right = NULL;
    if(root == NULL)
    {
        root = temp;
    }
    else{
        struct node *current=new node();
        current=root;
        while(current != NULL){
            if(current->data > temp->data){
                if (current->left == NULL) {
                    current->left = temp;
                    return;
                    }
                    current = current->left;
                }

                else if(current->data < temp->data){
                    if (current->right == NULL) {
                        current->right = temp;
                        return;
                    }current=current->right;
                }
    }
}
}
void inOrder(node* root) {
    if (root == NULL) {
        return;
    }
    inOrder(root->left);
    cout << root->data << " ";
    inOrder(root->right);
}
void preOrder(node* root) {
    if (root == NULL) {
        return;
    }
    cout << root->data << " ";
    preOrder(root->left);
    preOrder(root->right);
}
void postOrder(node* root) {
    if (root == NULL) {
        return;
    }
    postOrder(root->left);
    postOrder(root->right);
    cout << root->data << " ";
}

bool search_node(node* root, int value) {
    if (root == NULL) {
        return false;
    }
    if (root->data == value) {
        return true;
    }
    if (value < root->data) {
        return search_node(root->left, value);
    }
    return search_node(root->right, value);
}

int main(){

    int ch;
    char v;

	do{
        cout<<"\n1. Insert in Queue"<<endl;
        cout<<"2. Display"<<endl;
        cout<<"3. Search"<<endl;
        cout<<"4.. Exit\n"<<endl;
        cout<<"Enter choice: ";
        cin>>ch;
        switch(ch){
            case 1:{
                int n;
                cout<<"Enter number of node you want to enter :- ";
                cin>> n;
                    for(int i=1;i<=n;i++){
                        int value;
                        string bname,author;
                        cout<<"Enter Node value: ";
                        cin>>value;
                        insert(value);
                        cout<<"\n";
                    }
            break;
            }
            case 2:
                cout<<"InOrder Traversal  : ";
                inOrder(root);
                cout<<"\nPreOrder Traversal : ";
                preOrder(root);
                cout<<"\nPostOrder Traversal: ";
                postOrder(root);
                cout<<"\n";
            break;
            case 3:
                {
                int value;
                cout<<"Enter value of node to be search: ";
                cin>>value;

                if (search_node(root,value)) {
                    cout << value << " found in the BST." << std::endl;
                }
                else {
                    cout << value << " not found in the BST." << std::endl;
                }
                }
                break;
            case 4:
                cout<<"Exit"<<endl;
                break;
            }
	}while(ch!=4);
}


============================================================================================
BOOK BST by title as node value
============================================================================================
#include <iostream>
#include <iomanip>
#include<string>

using namespace std;

struct book_node
{
    int b_id;
    std::string btitle;
    std::string bauthor;
    int bprice;
    int bpages;
    struct book_node *left;
    struct book_node *right;
};

struct book_node *root = NULL;
void insert(int b_id,string btitle,string bauthor,int bprice,int bpages)
{
    struct book_node *data=new book_node();

    data->b_id=b_id;
    data->btitle=btitle;
    data->bauthor=bauthor;
    data->bprice=bprice;
    data->bpages=bpages;
    data->left=data->right=NULL;
    if(root == NULL)
    {
        root = data;
    }
    else{
        struct book_node *current=new book_node();
        current=root;
        while(current != NULL){
            if(current->btitle > data->btitle){
                if (current->left == NULL) {
                    current->left = data;
                    return;
                    }
                    current = current->left;
                }

                else if(current->btitle < data->btitle){
                    if (current->right == NULL) {
                        current->right = data;
                        return;
                    }current=current->right;
                }
    }
}
}

void inOrderTraversal(book_node* root) {
    if (root) {
        // Traverse the left subtree
        inOrderTraversal(root->left);

        // Print the book record
         cout<< "ID: " << root->b_id << "/ Book Title: "<< root->btitle << " / Author: " << root->bauthor << " / Price: " << root->bprice << " / Pages: " << root->bpages << "\n"<<endl;

        // Traverse the right subtree
        inOrderTraversal(root->right);
    }
}

void display()
{
    if (root == NULL)
    {
        cout << "Tree is empty" << endl;
    }
    else
    {
        inOrderTraversal(root);
    }
}

bool search_book(book_node* root, const string value) {
    if (root == nullptr) {
        return false;
    }

    if (root->btitle == value) {
        return true;
    }

    if (value < root->btitle) {
        return search_book(root->left, value);
    } else {
        return search_book(root->right, value);
    }
}


int main(){

    int ch;
    char v;

	do{
        cout<<"\n1. Insert in Queue"<<endl;
        cout<<"2. Display"<<endl;
        cout<<"3. Search"<<endl;
        cout<<"4. Exit\n"<<endl;
        cout<<"Enter choice: ";
        cin>>ch;
        switch(ch){
            case 1:
                int n;
                cout<<"Enter number of book to enter :- ";
                cin>> n;
                    for(int i=1;i<=n;i++){
                        int book_id,price,page;
                        std::string btitle,author;
                        cout<<"Enter book id: ";
                        cin>>book_id;
                        cin.ignore();
                        cout<<"Enter book title: ";
                        getline(cin, btitle);

                        cout<<"Enter book author: ";
                        getline(cin, author);

                        cout<<"Enter book price: ";
                        cin>>price;

                        cout<<"Enter book page: ";
                        cin>>page;

                        insert(book_id,btitle,author,price,page);
                        cout<<"\n";
                    }
            break;

            case 2:
                display();
            break;
            case 3:{
                std::string name;
                cout<<"Enter book title: ";
                cin.ignore();
                getline(cin, name);

                if (search_book(root,name)) {
                    cout << name << " book found in the Book records." << endl;
                }
                else {
                    cout << name << " book not found in the Book records." << endl;
                }
            break;
            }

            case 4:
                cout<<"Exit"<<endl;
            default:
                cout << "Invalid choice. Please select a valid option." << endl;
            }
	}while(ch!=4);
}


=======================================================================================
Shortest Path
=========================================================================================
#include<iostream>
#include<algorithm>

#define INF 99999
#define MAX 10

using namespace std;

void floydWarshall(int graph[MAX][MAX], int V) {
    int dist[MAX][MAX];

    // Initialize the distance matrix with the given graph
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            dist[i][j] = graph[i][j];
        }
    }

    // Apply the Floyd-Warshall algorithm
    for (int k = 0; k < V; k++) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    // Print the resulting distance matrix
    cout << "Shortest distances between every pair of vertices:\n";
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (dist[i][j] == INF) {
                cout << "INF ";
            } else {
                cout << dist[i][j] << " ";
            }
        }
        cout << endl;
    }
}

int main() {
    int V;

    cout << "Enter the number of vertices: ";
    cin >> V;

    int graph[MAX][MAX];

    cout << "Enter the adjacency matrix representing the graph (INF for no edge):\n";
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            cin >> graph[i][j];
            if (graph[i][j] == -1) {
                graph[i][j] = INF; // Use -1 as input to represent INF
            }
        }
    }

    floydWarshall(graph, V);

    return 0;
}

=============================================================================================
Use Hash Function
=======================================================================================
#include <iostream>
#include <list>

#define SIZE 30

class HashTable {
private:
    std::list<int> table[SIZE];

public:
    // Hash function
    int hashFunction(int key) {
        return key % SIZE;
    }

    // Insert a key into the hash table
    void insert(int key) {
        int index = hashFunction(key);
        table[index].push_back(key);
    }

    // Display the hash table
    void display() {
        for (int i = 0; i < SIZE; i++) {
            std::cout << "Index " << i << ": ";
            for (const auto& value : table[i]) {
                std::cout << value << " ";
            }
            std::cout << std::endl;
        }
    }
};

int main() {
    HashTable hashTable;

    int n, key;

    std::cout << "Enter the number of elements: ";
    std::cin >> n;

    std::cout << "Enter the elements:\n";
    for (int i = 0; i < n; i++) {
        std::cin >> key;
        hashTable.insert(key);
    }

    std::cout << "\nHash Table:\n";
    hashTable.display();

    return 0;
}

=====================================================================================
file sorting
==================================================================================
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <algorithm>
using namespace std;
int main() {

    const int arraySize = 1000;
    int randomNumberArray[arraySize];

    for (int i = 0; i < arraySize; ++i) {
        randomNumberArray[i] = rand() % 1000;
    }

    // Open a file for writing
    ofstream outputFile("random_numbers.txt");

    // Check if the file is opened successfully
    if (outputFile.is_open()) {
        // Write the array elements to the file
        for (int i = 0; i < arraySize; ++i) {
            outputFile << randomNumberArray[i] << "\n";
        }

        // Close the file
        outputFile.close();

        cout << "Data file created successfully." << std::endl;
    } else {
        std::cerr << "Error opening the file." << std::endl;
    }

    std::ifstream inputFile("random_numbers.txt");

    // Check if the file is opened successfully
    if (inputFile.is_open()) {
        // Read the numbers from the file into the array
        for (int i = 0; i < arraySize; ++i) {
            inputFile >> randomNumberArray[i];
        }

        // Close the file
        inputFile.close();

        // Sort the array
        sort(randomNumberArray, randomNumberArray + arraySize);

        // Open a file for writing sorted numbers
        std::ofstream sortedOutputFile("sorted_numbers.txt");

        // Check if the file is opened successfully
        if (sortedOutputFile.is_open()) {
            // Write the sorted array elements to the file
            for (int i = 0; i < arraySize; ++i) {
                sortedOutputFile << randomNumberArray[i] << "\n";
            }

            // Close the file
            sortedOutputFile.close();

            std::cout << "Sorted data file created successfully." << std::endl;
        } else {
            std::cerr << "Error opening the sorted file." << std::endl;
            return 1; // Return an error code
        }
    } else {
        std::cerr << "Error opening the file for reading." << std::endl;
        return 1; // Return an error code
    }

    return 0;
}

=================================================
find all reachable vertex from A graph vertex 
===================================================
Find All Reachable Vertices from A Graph Vertex.cpp
#include <iostream>

using namespace std;

struct Node
{
    int vertex, weight;
    Node* next;

    Node(int v, int w) : vertex(v), weight(w), next(nullptr) {}
};

class UndirectedGraph
{
public:
    UndirectedGraph(int numVertices) : N(numVertices)
    {
        adjList = new Node*[N]();
    }

    void addEdge(int from, int to, int weight)
    {
        Node* newNode = new Node(to, weight);
        newNode->next = adjList[from];
        adjList[from] = newNode;

        // Add the reverse edge from 'to' to 'from'
        Node* reverseNode = new Node(from, weight);
        reverseNode->next = adjList[to];
        adjList[to] = reverseNode;
    }

    void findReachableVertices(int startVertex)
    {
        bool visited[N] = {false};
        visited[startVertex] = true;

        cout << "Reachable vertices from vertex " << startVertex << ": ";
        for (int i = 0; i < N; ++i)
        {
            if (visited[i])
            {
                cout << i << " ";
                Node* currentNode = adjList[i];
                while (currentNode)
                {
                    int neighbor = currentNode->vertex;
                    visited[neighbor] = true;
                    currentNode = currentNode->next;
                }
            }
        }
        cout << endl;
    }

    ~UndirectedGraph()
    {
        for (int i = 0; i < N; ++i)
        {
            Node* current = adjList[i];
            while (current)
            {
                Node* temp = current;
                current = current->next;
                delete temp;
            }
        }
        delete[] adjList;
    }

private:
    int N;
    Node** adjList;
};

int main()
{
    UndirectedGraph graph(8);

    graph.addEdge(0, 1, 2);
    graph.addEdge(0, 2, 4);
    graph.addEdge(1, 4, 3);
    graph.addEdge(2, 3, 2);
    graph.addEdge(3, 1, 4);
    graph.addEdge(4, 3, 3);

    graph.findReachableVertices(0);

    // Adding disjoint nodes to demonstrate they can't be reached
    graph.addEdge(5, 6, 2);
    graph.addEdge(7, 8, 3);

    graph.findReachableVertices(5); // Should only show vertex 5
    graph.findReachableVertices(7); // Should only show vertex 7

    return 0;
}

==========================================
Graph Implementation
==========================================
Graph Implementation.cpp
#include <iostream>

using namespace std;

struct Node {
    int vertex, weight;
    Node* next;

    Node(int v, int w) : vertex(v), weight(w), next(nullptr) {}
};

class UndirectedGraph {
public:
    UndirectedGraph(int numVertices) : N(numVertices) {
        adjList = new Node*[N]();
    }

    void addEdge(int from, int to, int weight) {
        Node* newNode = new Node(to, weight);
        newNode->next = adjList[from];
        adjList[from] = newNode;

        // Add the reverse edge from 'to' to 'from'
        Node* reverseNode = new Node(from, weight);
        reverseNode->next = adjList[to];
        adjList[to] = reverseNode;
    }

    void printAdjacencyList() {
        cout << "Graph adjacency list:" << endl;
        for (int i = 0; i < N; ++i) {
            cout << i << " -> ";
            Node* current = adjList[i];
            while (current) {
                cout << "(" << current->vertex << ", " << current->weight << ") -> ";
                current = current->next;
            }
            cout << "nullptr" << endl;
        }
    }

    ~UndirectedGraph() {
        for (int i = 0; i < N; ++i) {
            Node* current = adjList[i];
            while (current) {
                Node* temp = current;
                current = current->next;
                delete temp;
            }
        }
        delete[] adjList;
    }

private:
    int N;
    Node** adjList;
};

int main() {
    UndirectedGraph graph(6);

    graph.addEdge(0, 1, 2);
    graph.addEdge(0, 2, 4);
    graph.addEdge(1, 4, 3);
    graph.addEdge(2, 3, 2);
    graph.addEdge(3, 1, 4);
    graph.addEdge(4, 3, 3);

    graph.printAdjacencyList();

    return 0;
}

================================
Graph Traversal -BFS & DFS
=================================
Graph Traversal.cpp
#include <iostream>
#include <queue>
#include <stack>

using namespace std;

struct Node {
    int vertex, weight;
    Node* next;

    Node(int v, int w) : vertex(v), weight(w), next(nullptr) {}
};

class UndirectedGraph {
public:
    UndirectedGraph(int numVertices) : N(numVertices) {
        adjList = new Node*[N]();
    }

    void addEdge(int from, int to, int weight) {
        Node* newNode = new Node(to, weight);
        newNode->next = adjList[from];
        adjList[from] = newNode;

        // Add the reverse edge from 'to' to 'from'
        Node* reverseNode = new Node(from, weight);
        reverseNode->next = adjList[to];
        adjList[to] = reverseNode;
    }

    void printAdjacencyList() {
        cout << "Graph adjacency list:" << endl;
        for (int i = 0; i < N; ++i) {
            cout << i << " -> ";
            Node* current = adjList[i];
            while (current) {
                cout << "(" << current->vertex << ", " << current->weight << ") -> ";
                current = current->next;
            }
            cout << "nullptr" << endl;
        }
    }

void DFS(int startVertex) {
        bool visited[N] = {false};
        stack<int> stack;

        visited[startVertex] = true;
        stack.push(startVertex);

        cout << "DFS traversal starting from vertex " << startVertex << ": ";
        while (!stack.empty()) {
            int currentVertex = stack.top();
            stack.pop();
            cout << currentVertex << " ";

            Node* currentNode = adjList[currentVertex];
            while (currentNode) {
                int neighbor = currentNode->vertex;
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    stack.push(neighbor);
                }
                currentNode = currentNode->next;
            }
        }
        cout << endl;
    }

    void BFS(int startVertex) {
        bool visited[N] = {false};
        queue<int> queue;

        visited[startVertex] = true;
        queue.push(startVertex);

        cout << "BFS traversal starting from vertex " << startVertex << ": ";
        while (!queue.empty()) {
            int currentVertex = queue.front();
            queue.pop();
            cout << currentVertex << " ";

            Node* currentNode = adjList[currentVertex];
            while (currentNode) {
                int neighbor = currentNode->vertex;
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
                currentNode = currentNode->next;
            }
        }
        cout << endl;
    }


    ~UndirectedGraph() {
        for (int i = 0; i < N; ++i) {
            Node* current = adjList[i];
            while (current) {
                Node* temp = current;
                current = current->next;
                delete temp;
            }
        }
        delete[] adjList;
    }

private:
    int N;
    Node** adjList;
};

int main() {
    UndirectedGraph graph(6);

    graph.addEdge(0, 1, 2);
    graph.addEdge(0, 2, 4);
    graph.addEdge(1, 4, 3);
    graph.addEdge(2, 3, 2);
    graph.addEdge(3, 1, 4);
    graph.addEdge(4, 3, 3);

    graph.printAdjacencyList();

    graph.DFS(0); // Perform DFS starting from vertex 0
    graph.BFS(0); // Perform BFS starting from vertex 0

    return 0;
}

=================================================
single pair shortest path
=============================================
single pair shortest path.cpp
#include <iostream>
#include <limits.h>
using namespace std;

#define V 9

int minDistance(int dist[], bool sptSet[]) {
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (!sptSet[v] && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

void printPath(int parent[], int j) {
    if (parent[j] == -1)
        return;

    printPath(parent, parent[j]);

    cout << j << " ";
}

void printSolution(int dist[], int parent[], int src, int dest) {
    cout << "Shortest Path from " << src << " to " << dest << ": " << endl;
    cout << "Vertex \t Distance \t Path" << endl;
    for (int i = 0; i < V; i++) {
        cout << i << " \t\t" << dist[i] << "\t" << src << " ";
        printPath(parent, i);
        cout << endl;
    }
}

void dijkstra(int graph[V][V], int src, int dest) {
    int dist[V];
    bool sptSet[V];
    int parent[V];

    for (int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        sptSet[i] = false;
        parent[src] = -1;
    }

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet);
        sptSet[u] = true;

        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
                parent[v] = u;
            }
    }

    printSolution(dist, parent, src, dest);
}

int main() {
    int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},
                       {4, 0, 8, 0, 0, 0, 0, 11, 0},
                       {0, 8, 0, 7, 0, 4, 0, 0, 2},
                       {0, 0, 7, 0, 9, 14, 0, 0, 0},
                       {0, 0, 0, 9, 0, 10, 0, 0, 0},
                       {0, 0, 4, 14, 10, 0, 2, 0, 0},
                       {0, 0, 0, 0, 0, 2, 0, 1, 6},
                       {8, 11, 0, 0, 0, 0, 1, 0, 7},
                       {0, 0, 2, 0, 0, 0, 6, 7, 0}};

    int source = 0;    // Hardcoded source vertex
    int destination = 4;  // Hardcoded destination vertex

    dijkstra(graph, source, destination);

    return 0;
}
